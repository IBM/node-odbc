const EventEmitter = require('events');
const async = require('async');
const binary = require('@mapbox/node-pre-gyp');
const path = require('path');

const { Connection } = require('./Connection');

const bindingPath = binary.find(path.resolve(path.join(__dirname, '../package.json')));

const odbc = require(bindingPath);

const REUSE_CONNECTIONS_DEFAULT = true;
const INITIAL_SIZE_DEFAULT = 10;
const INCREMENT_SIZE_DEFAULT = 10;
const MAX_SIZE_DEFAULT = Number.MAX_SAFE_INTEGER;
const SHRINK_DEFAULT = true;
const CONNECTION_TIMEOUT_DEFAULT = 0;
const LOGIN_TIMEOUT_DEFAULT = 0;
const FETCH_ARRAY_DEFAULT = false;
const MAX_ACTIVELY_CONNECTING = 1;

// A queue for tracking the connections 
class ConnectionQueue
{
  static queuedConnections = [];
  static activelyConnectingCount = 0;
  static maxActivelyConnecting = MAX_ACTIVELY_CONNECTING;

  static enqueue = async function(pool, promiseGenerator, configObject)
  {
      ConnectionQueue.queuedConnections.push({
          pool,
          promiseGenerator,
          configObject
      });
      ConnectionQueue.dequeue();
      return;
  }

  static dequeue = async function()
  {
    if (this.activelyConnectingCount >= this.maxActivelyConnecting) {
      return;
    }
    const item = this.queuedConnections.shift();
    if (!item) {
      return;
    }
    ConnectionQueue.activelyConnectingCount++;
    try {
      await item.promiseGenerator(item.configObject);
    } catch (error) {
      // Errors are handled in the promiseGenerator through emitting a
      // "connectionError" event. Error thrown and caught here simply to resolve
      // the promise generated by the promiseGenerator.
    }
    ConnectionQueue.activelyConnectingCount--;
    ConnectionQueue.dequeue();
    return;
  }
}

class Pool {

  constructor(connectionString) {

    this.connectionConfig = {};
    this.waitingConnectionWork = [];
    this.isOpen = false;
    this.freeConnections = [];
    this.connectionsBeingCreatedCount = 0;
    this.poolSize = 0;

    // Keeps track of when connections have sucessfully connected
    this.connectionEmitter = new EventEmitter();

    // Fires when a connection has been made
    this.connectionEmitter.on('connected', (connection) => {

      // A connection has finished connecting, but there is some waiting call
      // to connect() that is waiting for a connection. shift() that work from
      // the front of the waitingConnectionWork queue, then either call the
      // callback function provided by the user, or resolve the Promise that was
      // returned to the user.
      let connectionWork = this.waitingConnectionWork.shift();

      // A connection finished connecting, and there was no work waiting for
      // that connection to be made. Simply add it to the array of
      // freeConnections, and the next time work comes in it can simply be
      // retrieved from there.
      if (typeof connectionWork == 'undefined')
      {
        this.freeConnections.push(connection);
        return;
      }

      // If the user passed a callback function, then call the function with
      // no error in the first parameter and the connection in the second
      // parameter
      if (typeof connectionWork == 'function')
      {
        return connectionWork(null, connection);
      } 

      // If the user didn't pass a callback function, we returned a promise to
      // them. Resolve that promise with the connection that was just created.
      // Promise (stored resolve function)
      return connectionWork.resolveFunction(connection);
    });

    // Fires when a connection has errored. If there is no work waiting, then
    // the pool will simply be empty until the next time work is requested, at
    // which point there WILL be waiting work and they will get an error.
    this.connectionEmitter.on('connectionError', (error) => {
      let connectionWork = this.waitingConnectionWork.shift();
      if (typeof connectionWork == 'undefined')
      {
        return;
      }
      // If the user passed a callback function, then call the function with
      // the error in the first parameter
      if (typeof connectionWork == 'function')
      {
        return connectionWork(error, undefined);
      // If the user didn't pass a callback function, we returned a promise to
      // them. Reject that promise with the generated error
      } else {
        // Promise (stored resolve function)
        return connectionWork.rejectFunction(error);
      }
    });

    // connectionString is a string, so use defaults for all of the
    // configuration options.
    if (typeof connectionString === 'string') {
      this.connectionConfig.connectionString = connectionString;

      this.reuseConnections = REUSE_CONNECTIONS_DEFAULT;
      this.initialSize = INITIAL_SIZE_DEFAULT;
      this.incrementSize = INCREMENT_SIZE_DEFAULT;
      this.maxSize = MAX_SIZE_DEFAULT;
      this.shrink = SHRINK_DEFAULT;
      this.connectionConfig.connectionTimeout = CONNECTION_TIMEOUT_DEFAULT;
      this.connectionConfig.loginTimeout = LOGIN_TIMEOUT_DEFAULT;
      this.connectionConfig.fetchArray = FETCH_ARRAY_DEFAULT;
    }
    // connectionString is an object, so ensure that connectionString is a
    // property on that object and then copy over any configuration options.
    else if (typeof connectionString === 'object')
    {
      const configObject = connectionString;
      if (!Object.prototype.hasOwnProperty.call(configObject, 'connectionString')) {
        throw new TypeError('Pool configuration object must contain "connectionString" key');
      }

      this.connectionConfig.connectionString = configObject.connectionString;

      // reuseConnections
      this.reuseConnections = configObject.reuseConnections !== undefined ? configObject.reuseConnections : REUSE_CONNECTIONS_DEFAULT;

      // initialSize
      this.initialSize = configObject.initialSize !== undefined ? configObject.initialSize : INITIAL_SIZE_DEFAULT;

      // incrementSize
      this.incrementSize = configObject.incrementSize !== undefined ? configObject.incrementSize : INCREMENT_SIZE_DEFAULT;

      // maxSize
      this.maxSize = configObject.maxSize !== undefined ? configObject.maxSize : MAX_SIZE_DEFAULT;

      // shrink
      this.shrink = configObject.shrink !== undefined ? configObject.shrink : SHRINK_DEFAULT;

      // connectionTimeout
      this.connectionConfig.connectionTimeout = configObject.connectionTimeout !== undefined ? configObject.connectionTimeout : CONNECTION_TIMEOUT_DEFAULT;

      // loginTimeout
      this.connectionConfig.loginTimeout = configObject.loginTimeout !== undefined ? configObject.loginTimeout : LOGIN_TIMEOUT_DEFAULT;
      
      // fetchArray
      this.connectionConfig.fetchArray = configObject.fetchArray || FETCH_ARRAY_DEFAULT; 

      // connectingQueueMax
      // unlike other configuration values, this one is set statically on the
      // ConnectionQueue object and not on the Pool intance
      if (configObject.maxActivelyConnecting !== undefined)
      {
        ConnectionQueue.maxActivelyConnecting = configObject.maxActivelyConnecting
      }
    }
    // connectionString was neither a string nor and object, so throw an error.
    else
    {
      throw TypeError('Pool constructor must passed a connection string or a configuration object');
    }
  }

  // returns a open connection, ready to use.
  // should overwrite the 'close' function of the connection, and rename it is 'nativeClose', so
  // that that close can still be called.
  async connect(callback = undefined) {

    let connection;

    if (this.freeConnections.length == 0) {

      // If the number of connections waiting is more (shouldn't happen) or
      // equal to the number of connections connecting, and the number of
      // connections in the pool, in the process of connecting, and that will be
      // added is less than the maximum number of allowable connections, then
      // we will need to create MORE connections.
      if (this.connectionsBeingCreatedCount <= this.waitingConnectionWork.length &&
          this.poolSize + this.connectionsBeingCreatedCount + this.incrementSize <= this.maxSize)
      {
        this.increasePoolSize(this.incrementSize);
      }

      // If no callback was provided when connect was called, we need to create
      // a promise to return back. We also need to save off the resolve function
      // of that promises callback, so that we can call it to resolve the
      // function we returned
      if (typeof callback == 'undefined') {
        let resolveConnectionPromise;
        let rejectConnectionPromise;

        const promise = new Promise((resolve, reject) => {
          resolveConnectionPromise = resolve;
          rejectConnectionPromise = reject;
        });
        const promiseObj = {
          promise: promise,
          resolveFunction: resolveConnectionPromise,
          rejectFunction: rejectConnectionPromise,
        }
        // push the promise onto the waitingConnectionWork queue, then return
        // it to the user
        this.waitingConnectionWork.push(promiseObj);
        return promise;
      }
      // If a callback was provided, we can just add that to the
      // waitingConnectionWork queue, then return undefined to the user. Their
      // callback will execute when a connection is ready
      else
      {
        this.waitingConnectionWork.push(callback)
        return undefined;
      }
    }
    // Else, there was a free connection available for the user, so either
    // return an immediately resolved promise, or call their callback
    // immediately.
    else
    {
      connection = this.freeConnections.pop();

      // promise...
      if (typeof callback === 'undefined') {
        return Promise.resolve(connection);
      } else {
        // ...or callback
        return callback(null, connection);
      }
    }
  };

  async query(sql, params, opts, cb) {
    // determine the parameters passed
    let callback = cb;
    let parameters = params;
    let options = opts;

    if (typeof callback === 'undefined') {
      if (typeof options === 'function')
      {
        callback = options;
        if (typeof parameters === 'object' && !Array.isArray(parameters))
        {
          options = parameters;
          parameters = null;
        } else {
          options = null;
        }
      } else if (
        typeof options === 'undefined' &&
        typeof parameters === 'function')
      {
        callback = parameters;
        options = null;
        parameters = null;
      }
    }

    if (typeof callback !== 'function') {
      return new Promise((resolve, reject) => {
        this.connect((error, connection) => {
          if (error) {
            reject(error);
          }

          connection.query(sql, parameters, options, (error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
            connection.close();
          });
        });
      });
    }

    // ...or callback
    this.connect((error, connection) => {
      if (error) {
        throw error;
      }

      return connection.query(sql, parameters, options, (error, result) => {
        // after running, close the connection whether error or not
        process.nextTick(() => {
          callback(error, result);
        });
        connection.close();
      });
    });
  }

  // close the pool and all of the connections
  async close(callback = undefined) {
    const connections = [...this.freeConnections];
    this.freeConnections.length = 0;
    this.isOpen = false;

    if (typeof callback === 'undefined') {
      return new Promise((resolve, reject) => {
        async.each(connections, (connection, cb) => {
          connection.nativeClose((error) => {
            this.poolSize--;
            cb(error);
          });
        }, (error) => {
          if (error) {
            reject(error);
          } else {
            resolve(error);
          }
        });
      });
    }

    async.each(this.freeConnections, (connection, cb) => {
      connection.nativeClose((error) => {
        this.poolSize--;
        cb(error);
      });
    }, error => callback(error));
  }

  async init(callback = undefined) {
    if (!this.isOpen) {
      this.isOpen = true;
      // promise...
      if (typeof callback === 'undefined') {
        return new Promise(async (resolve, reject) => {
          try {
            await this.increasePoolSize(this.initialSize);
            // Try to get one connection during init to make sure there were
            // no errors with the connection string
            const connection = await this.connect();
            this.freeConnections.unshift(connection);
            resolve();
          } catch (error) {
            reject(error);
          }
        });
      }

      // ...or callback
      try {
        await this.increasePoolSize(this.initialSize);
        let connection = await this.connect();
        connection.close();
      } catch (error) {
        return callback(error);
      }
      return callback(null);
    }
    return undefined;
  }

  generateConnectPromise = function(connectionConfig) {
    return new Promise((resolve, reject) => {
      odbc.connect(connectionConfig, (error, nativeConnection) => {
        if (error) {
          // When there is a connection error, emit a "connectionError" event
          // with the error that is then either handled by any waiting work, or
          // is silently swallowed if no work is waiting. This is so that a bad
          // attempt at connecting doesn't throw an uncatchable error when there
          // is no user work, crashing the entire application.
          //
          // Catchable errors occur:
          // 1. When a pool is initialized and there was a problem with the
          // first connection (no network, bad connection string, etc.)
          // 2. When a user is attempting to do work and there are no active
          // connections, the pool will attempt to connect, emit the error, and
          // send it to the user work that was waiting (either as an error
          // parameter in the user's callback, or as a thrown error that the
          // user has to catch.)
          this.pool.connectionEmitter.emit('connectionError', error);

          // This reject is swallowed in the ConnectionQueue's dequeue function
          // in all cases, and is simply to end the Promise that was generated
          // by generateConnectPromise.
          reject(error);
          return;
        }

        this.pool.connectionsBeingCreatedCount--;
        this.pool.poolSize++;
        let connection = new Connection(nativeConnection);
        connection.nativeClose = connection.close;

        if (this.pool.reuseConnections) {
          connection.close = async (closeCallback = undefined) => {
            this.pool.connectionEmitter.emit('connected', connection);

            if (typeof closeCallback === 'undefined') {
              return new Promise((resolve, reject) => {
                resolve();
              })
            }

            return closeCallback(null);
          };
        } else {
          connection.close = async (closeCallback = undefined) => {
            this.pool.increasePoolSize(1);
            if (typeof closeCallback === 'undefined') {
              return new Promise((resolve, reject) => {
                connection.nativeClose((error, result) => {
                  this.pool.poolSize--;
                  if (error) {
                    reject(error);
                  } else {
                    resolve(result);
                  }
                });
              });
            }
      
            connection.nativeClose(closeCallback);
          }
        }

        this.pool.connectionEmitter.emit('connected', connection);
        resolve();
      });
    });
  }

  // odbc.connect runs on an AsyncWorker, so this is truly non-blocking
  async increasePoolSize(count) {
    this.connectionsBeingCreatedCount += count;
    for (let i = 0; i < count; i++)
    {
      ConnectionQueue.enqueue(this, this.generateConnectPromise, this.connectionConfig);
    }
  }
}

module.exports.Pool = Pool;
